() set_default_initial_data() impure {
  set_data(begin_cell().store_uint(0, 64).end_cell());
}

;; Every test name should start with "__test"
int __test_example() {
    set_default_initial_data();

    cell message = begin_cell().store_uint(10, 32).end_cell();
    ;; when calling contract's method, 'invoke_method' should be used
    ;; it catches exceptions, and computes gas usage
    (int exit_code, int gas_used1, _) = invoke_method(recv_internal, [message.begin_parse()]);
    throw_if(101, exit_code != 0);
    var (int exit_code, int gas_used2, stack) = invoke_method(get_total, []);
    throw_if(102, exit_code != 0);
    [int total] = stack;
    throw_if(103, total != 10);
    return gas_used1 + gas_used2;
}

;; by default 'persistent data' is not copied from previous test
int __test_no_initial_data_should_fail() {
    (int exit_code, int gas_used, _) = invoke_method(get_total, []);
    throw_if(101, exit_code == 0);
    return gas_used;
}

int __test_set_data() {
  return __test_example();
}

;; you can copy 'persistent data' from previous test by calling `get_prev_c4()`
int __test_data_from_prev_test() {
    set_data(get_prev_c4());
    var (int exit_code, int gas_used, stack) = invoke_method(get_total, []);
    throw_if(101, exit_code != 0);
    var [total] = stack;
    throw_if(102, total != 10);
    return gas_used;
}


int __test_throw_doesnt_corrupt_stack() {
    int check_stack_is_not_corrupted = 123;
    (int exit_code, int gas_used, _) = invoke_method(get_total, []);
    throw_if(101, exit_code == 0); ;; it throws because persistent data is empty
    ;; even if contract method throws an exception, test suite should not be affected
    throw_if(102, check_stack_is_not_corrupted != 123);
    return gas_used;
}



(int, cell) build_test_cell(int x, int y) {
  return (12345, begin_cell().store_uint(x, 64).store_uint(y, 64).end_cell());
}

int __test_not_integer_return_types() {
  var (int exit_code, int gas_used, stack) = invoke_method(build_test_cell, [100, 500]);
  throw_if(101, exit_code != 0);
  [int res, cell c] = stack;
  throw_if(102, res != 12345);
  slice s = c.begin_parse();
  throw_if(103, s~load_uint(64) != 100);
  throw_if(104, s~load_uint(64) != 500);
  return gas_used;
}

() empty_method() inline method_id {

}

;; returned 'gas used' also contains gas used by a wrapper.
;; It is ~roughly constant, so when developers are optimizing
;; their contracts, they should care about differences in gas usage
;; before and after optimizations, not absolute values.
int __test_empty_method_gas_consumption() method_id {
  var (_, int gas_used, _) = invoke_method(empty_method, []);
  throw_if(101, gas_used != 901);
  return gas_used;
}

;; You can return several values as tuples, they will be shown in the output
[int, int, int] __test_can_return_complex_type_from_test() {
  set_default_initial_data();

  cell message = begin_cell().store_uint(10, 32).end_cell();
  (int exit_code, int gas_used1, _) = invoke_method(recv_internal, [message.begin_parse()]);
  throw_if(101, exit_code != 0);

  cell message = begin_cell().store_uint(100, 32).end_cell();
  (int exit_code, int gas_used2, _) = invoke_method(recv_internal, [message.begin_parse()]);
  throw_if(102, exit_code != 0);

  cell message = begin_cell().store_uint(10, 32).end_cell();
  (int exit_code, int gas_used3, _) = invoke_method(recv_internal, [message.begin_parse()]);
  throw_if(103, exit_code != 0);

  return [gas_used1, gas_used2, gas_used3];
}